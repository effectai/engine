/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedClaimInstruction,
  type ParsedCloseInstruction,
  type ParsedEnterInstruction,
  type ParsedInitInstruction,
  type ParsedInitIntermediaryVaultInstruction,
  type ParsedSyncInstruction,
  type ParsedTopupInstruction,
} from '../instructions';

export const EFFECT_REWARD_PROGRAM_ADDRESS =
  'effRBsQPi2Exq4NWN6SPiCQk4E6BvXkqiBeu6saMxoi' as Address<'effRBsQPi2Exq4NWN6SPiCQk4E6BvXkqiBeu6saMxoi'>;

export enum EffectRewardAccount {
  ReflectionAccount,
  RewardAccount,
  StakeAccount,
}

export function identifyEffectRewardAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): EffectRewardAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([205, 153, 160, 54, 239, 26, 219, 188])
      ),
      0
    )
  ) {
    return EffectRewardAccount.ReflectionAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([225, 81, 31, 253, 84, 234, 171, 129])
      ),
      0
    )
  ) {
    return EffectRewardAccount.RewardAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([80, 158, 67, 124, 50, 189, 192, 255])
      ),
      0
    )
  ) {
    return EffectRewardAccount.StakeAccount;
  }
  throw new Error(
    'The provided account could not be identified as a effectReward account.'
  );
}

export enum EffectRewardInstruction {
  Claim,
  Close,
  Enter,
  Init,
  InitIntermediaryVault,
  Sync,
  Topup,
}

export function identifyEffectRewardInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): EffectRewardInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([62, 198, 214, 193, 213, 159, 108, 210])
      ),
      0
    )
  ) {
    return EffectRewardInstruction.Claim;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([98, 165, 201, 177, 108, 65, 206, 96])
      ),
      0
    )
  ) {
    return EffectRewardInstruction.Close;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([139, 49, 209, 114, 88, 91, 77, 134])
      ),
      0
    )
  ) {
    return EffectRewardInstruction.Enter;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100])
      ),
      0
    )
  ) {
    return EffectRewardInstruction.Init;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([136, 233, 11, 94, 192, 117, 195, 255])
      ),
      0
    )
  ) {
    return EffectRewardInstruction.InitIntermediaryVault;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([4, 219, 40, 164, 21, 157, 189, 88])
      ),
      0
    )
  ) {
    return EffectRewardInstruction.Sync;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([126, 42, 49, 78, 225, 151, 99, 77])
      ),
      0
    )
  ) {
    return EffectRewardInstruction.Topup;
  }
  throw new Error(
    'The provided instruction could not be identified as a effectReward instruction.'
  );
}

export type ParsedEffectRewardInstruction<
  TProgram extends string = 'effRBsQPi2Exq4NWN6SPiCQk4E6BvXkqiBeu6saMxoi',
> =
  | ({
      instructionType: EffectRewardInstruction.Claim;
    } & ParsedClaimInstruction<TProgram>)
  | ({
      instructionType: EffectRewardInstruction.Close;
    } & ParsedCloseInstruction<TProgram>)
  | ({
      instructionType: EffectRewardInstruction.Enter;
    } & ParsedEnterInstruction<TProgram>)
  | ({
      instructionType: EffectRewardInstruction.Init;
    } & ParsedInitInstruction<TProgram>)
  | ({
      instructionType: EffectRewardInstruction.InitIntermediaryVault;
    } & ParsedInitIntermediaryVaultInstruction<TProgram>)
  | ({
      instructionType: EffectRewardInstruction.Sync;
    } & ParsedSyncInstruction<TProgram>)
  | ({
      instructionType: EffectRewardInstruction.Topup;
    } & ParsedTopupInstruction<TProgram>);
