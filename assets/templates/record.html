<div id="app" style="text-align: center">
  <h1>Effect AI - Sentence Reader</h1>

  <hr />

  <div class="mx-auto" style="max-width: 80%">
    <p class="mb-5">Click <b>Record</b> then read the sentence aloud</p>

    <div class="box">
      <p class="is-size-4 has-text-weight-semibold" v-cloak>{{sentence}}</p>
    </div>

     <div class="container mb-5">
      <canvas v-if="isRecording" ref="visualizer" width="400" height="100" style="margin: 1rem auto; display: block;"></canvas>
      <button v-if="!isRecording" @click.prevent="startRecording" class="button is-primary is-medium mx-2">Record</button>
      <button v-cloak v-else @click.prevent="stopRecording" class="button is-danger is-medium mx-2">Stop</button>
      <button v-cloak v-if="audioUrl!=''" @click.prevent="playAudio" class="button is-link is-medium mx-2">Replay</button>
     </div>

    <audio ref="audioPlayer" :src="audioUrl" style="display: none;"></audio>

    <p class="is-size-7 mb-2">By clicking this button, you accept that the sentence contributed here will be added to a publicly available cc-0 licensed dataset.</p>

    <p style="color: red;" :class="{'is-hidden mb-3': !notComplete}">
      Task incomplete - Please complete all sections of the task
    </p>

    <button @click.prevent="uploadAndSubmit" class="button is-success is-large" :class="{'is-loading': btnLoading}">
      Submit
    </button>
  </div>

  <link rel="stylesheet" href="https://unpkg.com/bulma@0.9.4/css/bulma.min.css" />
  <link href="https://app.effect.network/force-defaults.css" rel="stylesheet" />

  <script src="https://cdn.jsdelivr.net/npm/ipfs-http-client/dist/index.min.js"></script>
  <script type="module">
    import { createApp } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";

    createApp({
      data() {
        return {
          title: "Effect AI Sentence Reader",
          recorder: null,
          audioChunks: [],
          audioUrl: "",
          audioBlob: "",
          isRecording: false,
          sentence: "${sentence}",
          ipfsCID: "",
          notComplete: false,
          visualizerCtx: null,
          analyser: null,
          audioContext: null,
          sourceNode: null,
          animationId: null,
          instructions: `
            <div>
              <p>Please follow these steps carefully to ensure your audio is useful and clear:</p>
              <br>
              <li><strong>Read the sentence exactly</strong> - Include every article and the correct plural form. Don't shorten or add words.</li>
              <br>
              <li><strong>Speak clearly and naturally</strong> - Don't trail off or adding extra phrases.</li>
              <br>
              <li><strong>Accent Forgiveness</strong> - Varied pronunciation is fine as long as the intended text is recognizable.</li>
              <br>
              <li><strong>Avoid too much background noise</strong> - Quiet ambient noise is OK, but distinct words from others interfere with accuracy.</li>
              <br>
              <li>If the recording is too quiet, noisy, or breaks up, please re-record until the full sentence is audible and matches the text.</li>
              <br>
              <li>Clip length should stay under ~15 seconds. Most sentences take under 10 seconds. Aim for brevity and clarity.</li>
            </div>`
        };
      },
      mounted() {
        window.top.postMessage(
          {
            type: 'task-instructions',
            instructions: this.instructions
          },
          "*"
        );
      },
      methods: {
        playAudio() {
          this.$refs.audioPlayer.play();
        },
        async startRecording() {
          this.isRecording = true;
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this.recorder = new MediaRecorder(stream);
          this.audioChunks = [];

          // Set up Web Audio API
          this.audioContext = new AudioContext();
          this.sourceNode = this.audioContext.createMediaStreamSource(stream);
          this.analyser = this.audioContext.createAnalyser();
          this.sourceNode.connect(this.analyser);
          this.analyser.fftSize = 256;

          const bufferLength = this.analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          this.visualizerCtx = this.$refs.visualizer.getContext('2d');

          const draw = () => {
            this.animationId = requestAnimationFrame(draw);
            this.analyser.getByteFrequencyData(dataArray);

            const canvas = this.$refs.visualizer;
            const width = canvas.width;
            const height = canvas.height;
            this.visualizerCtx.clearRect(0, 0, width, height);

            const barWidth = (width / bufferLength) * 1.5;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
              const barHeight = dataArray[i] / 2;
              this.visualizerCtx.fillStyle = 'rgb(' + (barHeight + 100) + ',50,150)';
              this.visualizerCtx.fillRect(x, height - barHeight, barWidth, barHeight);
              x += barWidth + 1;
            }
          };

          draw(); // start animation

          this.recorder.ondataavailable = (event) => this.audioChunks.push(event.data);
          this.recorder.onstop = () => {
            cancelAnimationFrame(this.animationId); // stop animation
            this.audioBlob = new Blob(this.audioChunks, { type: "audio/wav" });
            this.audioUrl = URL.createObjectURL(this.audioBlob);
            this.audioContext.close();
          };

          this.recorder.start();
        },
        stopRecording() {
          if (this.recorder && this.recorder.state === "recording") {
            this.recorder.stop();
            this.isRecording = false;
          }
        },
        async storeRecording() {
          const file = new File([this.audioBlob], "recording.wav", { type: "audio/wav" });
          const formData = new FormData();
          formData.append('path', file);
          try {
            const response = await fetch(this.ipfsHOST, {
              method: 'POST',
              body: formData,
            });
            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`Upload failed: ${errorText}`);
            }
            const result = await response.json();
            this.ipfsCID = result.Hash;
          } catch (error) {
            console.error('Error uploading to IPFS:', error);
          }
        },
        async uploadAndSubmit() {
          this.btnLoading = true;
          if (this.audioChunks.length === 0) {
            this.notComplete = true;
          } else {
            try {
              await this.storeRecording();
              parent.postMessage(
                {
                  task: "submit",
                  values: {
                    taskTitle: this.title,
                    sentence: this.sentence,
                    answer: "https://ipfs.effect.ai/ipfs/" + this.ipfsCID,
                  },
                },
                "*"
              );
            } catch (error) {
              console.error("Failed to upload to IPFS", error);
            }
          }
          this.btnLoading = false;
        },
      },
    }).mount("#app");
  </script>

  <style scoped>
    [v-cloak] {
      display: none;
    }
  </style>
</div>
