<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Effect AI - Sentence Reader (WaveSurfer v7 record)</title>
  <link rel="stylesheet" href="https://unpkg.com/bulma@0.9.4/css/bulma.min.css" />
  <style>
    #waveform { height: 110px; margin: 1rem 0; }
    [v-cloak] { display: none; }
  </style>
</head>
<body>
<div id="app" style="text-align: center">
  <h1>Effect AI - Sentence Reader</h1>
  <hr />

  <div class="mx-auto" style="max-width: 80%">
    <p class="mb-5">Click <b>Record</b> then read the sentence aloud</p>

    <div class="box">
      <p class="is-size-4 has-text-weight-semibold" v-cloak>{{ sentence }}</p>
    </div>

    <!-- WaveSurfer container -->
    <div id="waveform" class="mb-4"></div>

    <div class="container mb-5">
      <button v-if="!isRecording" @click.prevent="startRecording" class="button is-primary is-medium mx-2">Record</button>
      <button v-else @click.prevent="stopRecording" class="button is-danger is-medium mx-2">Stop</button>
      <button v-if="audioUrl" @click.prevent="playRecorded" class="button is-link is-medium mx-2">Replay</button>
    </div>

    <p class="is-size-7 mb-2">
      By clicking this button, you accept that the sentence contributed here will be added to a publicly available cc-0 licensed dataset.
    </p>

    <p style="color: red;" :class="{'is-hidden mb-3': !notComplete}">
      Task incomplete - Please complete all sections of the task
    </p>

    <button @click.prevent="uploadAndSubmit" class="button is-success is-large" :class="{'is-loading': btnLoading}">
      Submit
    </button>
  </div>
</div>

<!-- WaveSurfer v7 + Record plugin (ESM) -->
<script type="module">
import { createApp } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";
import WaveSurfer from "https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.esm.js";
import RecordPlugin from "https://unpkg.com/wavesurfer.js@7/dist/plugins/record.esm.js";

createApp({
  data() {
    return {
      title: "Effect AI Sentence Reader",
      sentence: "Please replace this with your sentence to read aloud.",
      wavesurfer: null,
      recordPlugin: null,
      isRecording: false,
      audioBlob: null,
      audioUrl: "",
      ipfsCID: "",
      notComplete: false,
      btnLoading: false,
      instructions: `Please read the sentence exactly and clearly.`
    };
  },
  mounted() {
    // post instructions to parent (your previous behavior)
    window.top.postMessage({ type: "task-instructions", instructions: this.instructions }, "*");

    // Create the plugin instance (keep reference)
    this.recordPlugin = RecordPlugin.create({
      // options (optional)
      // renderRecordedAudio: true,     // plugin can render recorded audio automatically
      // scrollingWaveform: false,
      // mediaRecorderTimeslice: 1000,
    });

    // Create wavesurfer and attach the plugin
    this.wavesurfer = WaveSurfer.create({
      container: "#waveform",
      waveColor: "#ddd",
      progressColor: "#0000FF",
      cursorWidth: 0,
      height: 100,
      interact: false, // disable user interactions during record/playback if you want
      plugins: [this.recordPlugin],
    });

    // When a recording finishes, the plugin emits 'record-end' with the Blob
    this.recordPlugin.on("record-end", (blob) => {
      // store blob and make it playable
      this.audioBlob = blob;
      this.audioUrl = URL.createObjectURL(blob);

      // Load back into wavesurfer so waveform remains and can be replayed
      // Use load(url) which accepts blob URLs
      this.wavesurfer.load(this.audioUrl);

      // ensure UI updated
      this.isRecording = false;
    });

    // Optional: handle start event
    this.recordPlugin.on("record-start", () => {
      this.isRecording = true;
      this.audioBlob = null;
      this.audioUrl = "";
    });

    // Optional: progress event (fires while recording) — can be used for a timer
    this.recordPlugin.on("record-progress", (duration) => {
      // duration is seconds
      // e.g. update a display or stop if > max allowed
      // console.log("record-progress", duration);
    });

    // Optional: data-available (chunked)
    this.recordPlugin.on("record-data-available", (blob) => {
      // chunk blobs are provided if plugin configured with a timeslice
      // console.log('chunk', blob);
    });
  },
  methods: {
    // Start recording (requests mic permissions and shows live waveform)
    async startRecording() {
      try {
        // startRecording will request mic and start the recorder + live waveform
        await this.recordPlugin.startRecording();
        // plugin emits record-start -> handled above
      } catch (err) {
        console.error("startRecording failed:", err);
        this.isRecording = false;
        // If permission denied or other error, inform user
        alert("Could not start recording. Make sure microphone permission is allowed and you are on https/localhost.");
      }
    },

    // Stop the recording — proper v7 method
    stopRecording() {
      try {
        // stopRecording triggers record-end event with Blob
        this.recordPlugin.stopRecording();
        // optionally also stopMic to stop the live mic stream (if you used startMic separately)
        // this.recordPlugin.stopMic();
      } catch (err) {
        console.error("stopRecording failed:", err);
      }
    },

    // Play the just-recorded audio (wavesurfer holds the buffer after load)
    playRecorded() {
      if (!this.audioUrl) return;
      // wavesurfer.playPause toggles play/pause
      this.wavesurfer.playPause();
    },

    // Upload to IPFS (placeholder — adjust ipfsHOST or logic to your stack)
    async uploadAndSubmit() {
      this.btnLoading = true;
      if (!this.audioBlob) {
        this.notComplete = true;
        this.btnLoading = false;
        return;
      }
      try {
        const file = new File([this.audioBlob], "recording.wav", { type: "audio/wav" });
        const formData = new FormData();
        formData.append("path", file);
        // Replace with your IPFS upload endpoint
        const response = await fetch(this.ipfsHOST || "/api/upload", {
          method: "POST",
          body: formData,
        });
        if (!response.ok) throw new Error("Upload failed");
        const result = await response.json();
        this.ipfsCID = result.Hash || result.cid || result.id;
        parent.postMessage({
          task: "submit",
          values: {
            taskTitle: this.title,
            sentence: this.sentence,
            answer: "https://ipfs.effect.ai/ipfs/" + this.ipfsCID
          }
        }, "*");
      } catch (err) {
        console.error("Failed to upload", err);
      } finally {
        this.btnLoading = false;
      }
    }
  }
}).mount("#app");
</script>
</body>
</html>
