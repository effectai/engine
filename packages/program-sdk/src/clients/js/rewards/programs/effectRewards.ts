/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedClaimInstruction,
  type ParsedCloseInstruction,
  type ParsedEnterInstruction,
  type ParsedInitInstruction,
  type ParsedInitIntermediaryVaultInstruction,
  type ParsedSyncInstruction,
  type ParsedTopupInstruction,
} from '../instructions';

export const EFFECT_REWARDS_PROGRAM_ADDRESS =
  'effRBsQPi2Exq4NWN6SPiCQk4E6BvXkqiBeu6saMxoi' as Address<'effRBsQPi2Exq4NWN6SPiCQk4E6BvXkqiBeu6saMxoi'>;

export enum EffectRewardsAccount {
  ReflectionAccount,
  RewardAccount,
  StakeAccount,
}

export function identifyEffectRewardsAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): EffectRewardsAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([205, 153, 160, 54, 239, 26, 219, 188])
      ),
      0
    )
  ) {
    return EffectRewardsAccount.ReflectionAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([225, 81, 31, 253, 84, 234, 171, 129])
      ),
      0
    )
  ) {
    return EffectRewardsAccount.RewardAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([80, 158, 67, 124, 50, 189, 192, 255])
      ),
      0
    )
  ) {
    return EffectRewardsAccount.StakeAccount;
  }
  throw new Error(
    'The provided account could not be identified as a effectRewards account.'
  );
}

export enum EffectRewardsInstruction {
  Claim,
  Close,
  Enter,
  Init,
  InitIntermediaryVault,
  Sync,
  Topup,
}

export function identifyEffectRewardsInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): EffectRewardsInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([62, 198, 214, 193, 213, 159, 108, 210])
      ),
      0
    )
  ) {
    return EffectRewardsInstruction.Claim;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([98, 165, 201, 177, 108, 65, 206, 96])
      ),
      0
    )
  ) {
    return EffectRewardsInstruction.Close;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([139, 49, 209, 114, 88, 91, 77, 134])
      ),
      0
    )
  ) {
    return EffectRewardsInstruction.Enter;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100])
      ),
      0
    )
  ) {
    return EffectRewardsInstruction.Init;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([136, 233, 11, 94, 192, 117, 195, 255])
      ),
      0
    )
  ) {
    return EffectRewardsInstruction.InitIntermediaryVault;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([4, 219, 40, 164, 21, 157, 189, 88])
      ),
      0
    )
  ) {
    return EffectRewardsInstruction.Sync;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([126, 42, 49, 78, 225, 151, 99, 77])
      ),
      0
    )
  ) {
    return EffectRewardsInstruction.Topup;
  }
  throw new Error(
    'The provided instruction could not be identified as a effectRewards instruction.'
  );
}

export type ParsedEffectRewardsInstruction<
  TProgram extends string = 'effRBsQPi2Exq4NWN6SPiCQk4E6BvXkqiBeu6saMxoi',
> =
  | ({
      instructionType: EffectRewardsInstruction.Claim;
    } & ParsedClaimInstruction<TProgram>)
  | ({
      instructionType: EffectRewardsInstruction.Close;
    } & ParsedCloseInstruction<TProgram>)
  | ({
      instructionType: EffectRewardsInstruction.Enter;
    } & ParsedEnterInstruction<TProgram>)
  | ({
      instructionType: EffectRewardsInstruction.Init;
    } & ParsedInitInstruction<TProgram>)
  | ({
      instructionType: EffectRewardsInstruction.InitIntermediaryVault;
    } & ParsedInitIntermediaryVaultInstruction<TProgram>)
  | ({
      instructionType: EffectRewardsInstruction.Sync;
    } & ParsedSyncInstruction<TProgram>)
  | ({
      instructionType: EffectRewardsInstruction.Topup;
    } & ParsedTopupInstruction<TProgram>);
